# cursor_instructions.md

Project Goal
Generate a full, production-ready Django 5 + DRF microservice that provides film search and rich film-detail aggregation for other teams (frontend, mobile).  
No frontend code of any kind.

Non-Negotiable Tech Stack
- Python 3.10+
- Django 5.x
- djangorestframework
- django-environ (for env config)
- psycopg2-binary
- httpx + tenacity (for resilient HTTP client)
- drf-spectacular (OpenAPI 3 auto-generation)
- pytest + pytest-django
- Native models.JSONField
- django-allauth (only scaffolding, no UI)

Exact Repository Structure to Create
/backend/
  manage.py
  filmosphere/
    __init__.py
    settings.py
    urls.py
    wsgi.py
    asgi.py
  core/
    __init__.py
    apps.py
    services/
      __init__.py
      http_client.py
      imdb_service.py
      kinocheck_service.py
      watchmode_service.py
    utils/
      __init__.py
      logging.py
      decorators.py
  films/
    __init__.py
    apps.py
    models.py
    serializers.py
    services/
      __init__.py
      film_cache.py
      film_aggregator.py
    views.py
    urls.py
    tests/
      test_services.py
      test_views.py
  api/
    __init__.py
    urls.py
  requirements.txt
  pytest.ini
  .env.example
  .gitignore
  Dockerfile
  docker-compose.yml
  docs/
    API.md
    openapi.yaml          # generated by drf-spectacular
  filmosphere_postman_collection.json   # already exists – keep & respect naming
  filmosphere_openapi.yaml              # reference spec – match paths closely

Exact Film Model (films/models.py)
import uuid
from django.db import models

class Film(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    imdb_id = models.CharField(max_length=20, unique=True, db_index=True)
    title = models.CharField(max_length=512, db_index=True)
    year = models.IntegerField(null=True, blank=True)
    poster_url = models.URLField(max_length=2000, null=True, blank=True)
    full_json = models.JSONField(null=True, blank=True)
    cached_at = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [
            models.Index(fields=['imdb_id']),
            models.Index(fields=['title']),
        ]

Environment Variables (.env.example – exact list)
DJANGO_SECRET_KEY=replace_with_secure_key
DJANGO_DEBUG=True
DATABASE_URL=postgres://filmouser:filmopass@postgres:5432/filmosphere
IMDBAPI_BASE=https://api.imdbapi.dev
KINO_BASE=https://api.kinocheck.de
KINO_API_KEY=your_key_here
WATCHMODE_BASE=https://api.watchmode.com/v1
WATCHMODE_API_KEY=your_watchmode_key
CACHE_TTL_HOURS=24
HTTP_TIMEOUT=10
HTTP_RETRIES=3

Endpoints (exact paths & behaviour)
1. GET /api/search?q=<query>
   → Calls IMDbService.search()
   → Returns { "query": str, "results": [{imdb_id, title, year, image, type}] }
   → Simple IP-based throttle

2. GET /api/films/{imdb_id}
   → Validate imdb_id format ^tt\d+$
   → Uses FilmAggregatorService.fetch_and_cache(imdb_id)
   → Returns full aggregated payload (see below)
   → 404 if IMDb reports not found

3. Optional helpers (recommended)
   GET /api/films/{imdb_id}/trailer
   GET /api/films/{imdb_id}/streaming

Response shape for /api/films/{imdb_id}
{
  "imdb_id": "tt1375666",
  "title": "...",
  "metadata": { ... },           # raw from IMDbAPI.dev
  "credits": { ... },
  "images": { ... },
  "videos": { ... },
  "parents_guide": { ... },
  "certificates": { ... },
  "release_dates": { ... },
  "trailer": { ... } | null,     # from KinoCheck
  "streaming": [ ... ],          # Watchmode sources region=TR
  "warnings": []                 # if any external call failed after retries
}

Service Classes – Exact Public Interfaces
# core/services/imdb_service.py
class IMDbService:
    def search(self, query: str) -> list[dict]: ...
    def get_metadata(self, imdb_id: str) -> dict: ...
    def get_credits(self, imdb_id: str) -> dict: ...
    def get_images(self, imdb_id: str) -> dict: ...
    def get_videos(self, imdb_id: str) -> dict: ...
    def get_parents_guide(self, imdb_id: str) -> dict: ...
    def get_certificates(self, imdb_id: str) -> dict: ...
    def get_release_dates(self, imdb_id: str) -> dict: ...

# core/services/kinocheck_service.py
class KinoCheckService:
    def get_trailer(self, imdb_id: str) -> dict | None: ...

# core/services/watchmode_service.py
class WatchmodeService:
    def lookup_title_id(self, imdb_id: str) -> int | None: ...
    def get_streaming_sources(self, watchmode_id: int) -> list[dict]: ...

# films/services/film_aggregator.py
class FilmAggregatorService:
    def fetch_and_cache(self, imdb_id: str) -> dict: ...

# films/services/film_cache.py
class FilmCacheService:
    def get_cached(self, imdb_id: str) -> dict | None: ...
    def save_cache(self, imdb_id: str, payload: dict): ...
    def is_fresh(self, imdb_id: str) -> bool: ...

HTTP Client (core/services/http_client.py)
- Use httpx (sync)
- Tenacity retry: 3 attempts, exponential backoff on 5xx + network errors
- Timeout from env (default 10s)
- Structured JSON logging with correlation-id header support
- Dependency-injected into every service (for easy mocking in tests)

Caching Logic
- Default TTL = 24 hours (CACHE_TTL_HOURS env var)
- If cached_at + TTL still valid → return full_json immediately
- On miss or stale → fetch everything (parallel where sensible), merge, save, return
- On partial external failure → still save & return what we have + add entry to "warnings"

Tests (required)
- Unit tests for all service methods (mocked HTTP client)
- FilmAggregatorService cache hit / miss / partial failure scenarios
- View tests using APIClient with mocked services
- Use pytest + pytest-django

Documentation & Deliverables
- drf-spectacular for auto OpenAPI → save as docs/openapi.yaml
- docs/API.md with curl examples and response samples
- Update Postman collection variables to {{base_url}} = http://localhost:8000
- README.md with full setup & verification steps
- Dockerfile + docker-compose.yml (web + postgres (redis optional, commented))

Verification Steps (include in README.md)
1. cp .env.example .env && edit keys
2. docker compose up -d --build
3. docker compose exec web python manage.py migrate
4. docker compose exec web python manage.py runserver 0.0.0.0:8000
5. curl "http://localhost:8000/api/search?q=Inception"
6. curl "http://localhost:8000/api/films/tt1375666"

Final Cursor Instructions
- Generate the entire project exactly as specified above
- All external calls must be mockable via dependency injection
- Add comprehensive docstrings to every public method
- Run pytest after generation and confirm all tests pass
- After completion, create generation_report.md summarising:
  • All created files
  • Implemented endpoints
  • How to run migrations / tests
  • Any deviations (should be none)

DO NOT generate any frontend, templates, static files, admin customisations beyond allauth scaffolding, or recommendation logic.

Now generate the full backend microservice.